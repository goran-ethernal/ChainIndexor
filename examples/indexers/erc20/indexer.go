// Code generated by indexer-gen. DO NOT EDIT.
package erc20

import (
	"database/sql"
	"errors"
	"fmt"
	"math/big"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/goran-ethernal/ChainIndexor/internal/logger"
	"github.com/goran-ethernal/ChainIndexor/pkg/config"
	"github.com/goran-ethernal/ChainIndexor/pkg/indexer"
	"github.com/russross/meddler"
	"github.com/goran-ethernal/ChainIndexor/examples/indexers/erc20/migrations"
)

// Compile-time check to ensure ERC20Indexer implements indexer.Indexer interface.
var _ indexer.Indexer = (*ERC20Indexer)(nil)

// ERC20Indexer indexes ERC20 events.
type ERC20Indexer struct {
	cfg config.IndexerConfig
	db  *sql.DB
	log *logger.Logger

	// Map of contract addresses to event topic hashes
	eventsToIndex map[common.Address]map[common.Hash]struct{}

	// Event signature hashes for quick lookup
	transferTopic common.Hash
	approvalTopic common.Hash
}

// NewERC20Indexer creates a new ERC20 indexer.
func NewERC20Indexer(cfg config.IndexerConfig, log *logger.Logger) (*ERC20Indexer, error) {
	// Run migrations to set up the database schema
	if err := migrations.RunMigrations(cfg.DB); err != nil {
		return nil, fmt.Errorf("failed to run migrations: %w", err)
	}

	// Create database connection from config
	database, err := sql.Open("sqlite3", cfg.DB.Path)
	if err != nil {
		return nil, fmt.Errorf("failed to create database: %w", err)
	}

	// Calculate event topic hashes
	transferTopic := crypto.Keccak256Hash([]byte("Transfer(address,address,uint256)"))
	approvalTopic := crypto.Keccak256Hash([]byte("Approval(address,address,uint256)"))

	// Build the events to index map
	eventsToIndex := make(map[common.Address]map[common.Hash]struct{})

	for _, contract := range cfg.Contracts {
		topics := make(map[common.Hash]struct{})

		for _, eventSig := range contract.Events {
			topic := crypto.Keccak256Hash([]byte(eventSig))
			topics[topic] = struct{}{}
		}

		// Parse contract address from string
		address := common.HexToAddress(contract.Address)
		eventsToIndex[address] = topics
	}

	return &ERC20Indexer{
		cfg:           cfg,
		db:            database,
		log:           log,
		eventsToIndex: eventsToIndex,
		transferTopic: transferTopic,
		approvalTopic: approvalTopic,
	}, nil
}

// GetType returns the type identifier of the indexer.
func (idx *ERC20Indexer) GetType() string {
	return "erc20"
}

// GetName returns the configured name of the indexer instance.
func (idx *ERC20Indexer) GetName() string {
	return idx.cfg.Name
}

// EventsToIndex returns the map of contract addresses to event topic hashes.
func (idx *ERC20Indexer) EventsToIndex() map[common.Address]map[common.Hash]struct{} {
	return idx.eventsToIndex
}

// HandleLogs processes a batch of logs and stores events.
func (idx *ERC20Indexer) HandleLogs(logs []types.Log) error {
	if len(logs) == 0 {
		return nil
	}

	tx, err := idx.db.Begin()
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer func() {
		if err := tx.Rollback(); err != nil && !errors.Is(err, sql.ErrTxDone) {
			idx.log.Errorf("failed to rollback transaction: %v", err)
		}
	}()
	transferCount := 0
	approvalCount := 0

	for _, log := range logs {
		if len(log.Topics) == 0 {
			continue
		}

		topic := log.Topics[0]

		switch topic {
		case idx.transferTopic:
			event, err := idx.parseTransfer(&log)
			if err != nil {
				idx.log.Warnf("failed to parse Transfer event at block %d, tx %s: %v",
					log.BlockNumber, log.TxHash.Hex(), err)
				continue
			}

			if err := meddler.Insert(tx, "transfers", event); err != nil {
				return fmt.Errorf("failed to insert transfer: %w", err)
			}
			transferCount++
		
		case idx.approvalTopic:
			event, err := idx.parseApproval(&log)
			if err != nil {
				idx.log.Warnf("failed to parse Approval event at block %d, tx %s: %v",
					log.BlockNumber, log.TxHash.Hex(), err)
				continue
			}

			if err := meddler.Insert(tx, "approvals", event); err != nil {
				return fmt.Errorf("failed to insert approval: %w", err)
			}
			approvalCount++
		
		}
	}

	if err := tx.Commit(); err != nil {
		return fmt.Errorf("failed to commit transaction: %w", err)
	}

	idx.log.Infof("Indexed %d transfers, %d approvals", transferCount, approvalCount)

	return nil
}

// HandleReorg handles a blockchain reorganization by removing data from the reorg point.
func (idx *ERC20Indexer) HandleReorg(blockNum uint64) error {
	tx, err := idx.db.Begin()
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer func() {
		if err := tx.Rollback(); err != nil && !errors.Is(err, sql.ErrTxDone) {
			idx.log.Errorf("failed to rollback transaction: %v", err)
		}
	}()

	
	// Delete transfers from the reorg point
	deleteTransfersQuery := `DELETE FROM transfers WHERE block_number >= ?`
	result, err := tx.Exec(deleteTransfersQuery, blockNum)
	if err != nil {
		return fmt.Errorf("failed to delete transfers: %w", err)
	}
	transfersDeleted, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to get rows affected for transfers: %w", err)
	}
	
	// Delete approvals from the reorg point
	deleteApprovalsQuery := `DELETE FROM approvals WHERE block_number >= ?`
	result, err = tx.Exec(deleteApprovalsQuery, blockNum)
	if err != nil {
		return fmt.Errorf("failed to delete approvals: %w", err)
	}
	approvalsDeleted, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to get rows affected for approvals: %w", err)
	}
	

	if err := tx.Commit(); err != nil {
		return fmt.Errorf("failed to commit transaction: %w", err)
	}

	idx.log.Infof("Handled reorg from block %d: deleted %d transfers, %d approvals",
		blockNum, transfersDeleted, approvalsDeleted)

	return nil
}

// StartBlock returns the block number from which this indexer should start.
func (idx *ERC20Indexer) StartBlock() uint64 {
	return idx.cfg.StartBlock
}

// Close closes the database connection.
func (idx *ERC20Indexer) Close() error {
	return idx.db.Close()
}


// parseTransfer parses a Transfer event from a log.
// Event signature: Transfer(address indexed from, address indexed to, uint256 value)
func (idx *ERC20Indexer) parseTransfer(log *types.Log) (*Transfer, error) {
	expectedTopics := 2 + 1 // signature + indexed params
	if len(log.Topics) != expectedTopics {
		return nil, fmt.Errorf("invalid Transfer event: expected %d topics, got %d",
			expectedTopics, len(log.Topics))
	}

	expectedDataSize := 1 * 32 // 1 non-indexed param(s)
	if len(log.Data) != expectedDataSize {
		return nil, fmt.Errorf("invalid Transfer event: expected %d bytes of data, got %d",
			expectedDataSize, len(log.Data))
	}
	from := common.BytesToAddress(log.Topics[1].Bytes())
	to := common.BytesToAddress(log.Topics[2].Bytes())
	valueBig := new(big.Int).SetBytes(log.Data[0:32])
	value := valueBig.String()

	return &Transfer{
		BlockNumber: log.BlockNumber,
		BlockHash:   log.BlockHash,
		TxHash:      log.TxHash,
		TxIndex:     log.TxIndex,
		LogIndex:    log.Index,
		From: from,
		To: to,
		Value: value,
	}, nil
}

// parseApproval parses a Approval event from a log.
// Event signature: Approval(address indexed owner, address indexed spender, uint256 value)
func (idx *ERC20Indexer) parseApproval(log *types.Log) (*Approval, error) {
	expectedTopics := 2 + 1 // signature + indexed params
	if len(log.Topics) != expectedTopics {
		return nil, fmt.Errorf("invalid Approval event: expected %d topics, got %d",
			expectedTopics, len(log.Topics))
	}

	expectedDataSize := 1 * 32 // 1 non-indexed param(s)
	if len(log.Data) != expectedDataSize {
		return nil, fmt.Errorf("invalid Approval event: expected %d bytes of data, got %d",
			expectedDataSize, len(log.Data))
	}
	owner := common.BytesToAddress(log.Topics[1].Bytes())
	spender := common.BytesToAddress(log.Topics[2].Bytes())
	valueBig := new(big.Int).SetBytes(log.Data[0:32])
	value := valueBig.String()

	return &Approval{
		BlockNumber: log.BlockNumber,
		BlockHash:   log.BlockHash,
		TxHash:      log.TxHash,
		TxIndex:     log.TxIndex,
		LogIndex:    log.Index,
		Owner: owner,
		Spender: spender,
		Value: value,
	}, nil
}

