// Code generated by indexer-gen. DO NOT EDIT.
package erc20

import (
	"context"
	"fmt"
	"strings"

	"github.com/goran-ethernal/ChainIndexor/pkg/indexer"
	"github.com/russross/meddler"
)

// Ensure ERC20Indexer implements indexer.Queryable
var _ indexer.Queryable = (*ERC20Indexer)(nil)

// QueryEvents retrieves events based on the provided query parameters.
func (idx *ERC20Indexer) QueryEvents(ctx context.Context, params indexer.QueryParams) (any, int, error) {
	// Determine which table to query based on event type (case-insensitive)
	var tableName string
	var scanFunc func(*ERC20Indexer, context.Context, string, []any) (any, error)

	eventType := strings.ToLower(params.EventType)
	switch eventType {
	case "transfer":
		tableName = "transfers"
		scanFunc = func(idx *ERC20Indexer, ctx context.Context, query string, args []any) (any, error) {
			rows, err := idx.db.QueryContext(ctx, query, args...)
			if err != nil {
				return nil, fmt.Errorf("failed to query Transfer events: %w", err)
			}
			defer rows.Close()

			var events []*Transfer
			if err := meddler.ScanAll(rows, &events); err != nil {
				return nil, fmt.Errorf("failed to scan Transfer events: %w", err)
			}
			return events, nil
		}
	case "approval":
		tableName = "approvals"
		scanFunc = func(idx *ERC20Indexer, ctx context.Context, query string, args []any) (any, error) {
			rows, err := idx.db.QueryContext(ctx, query, args...)
			if err != nil {
				return nil, fmt.Errorf("failed to query Approval events: %w", err)
			}
			defer rows.Close()

			var events []*Approval
			if err := meddler.ScanAll(rows, &events); err != nil {
				return nil, fmt.Errorf("failed to scan Approval events: %w", err)
			}
			return events, nil
		}
	default:
		return nil, 0, fmt.Errorf("unknown event type: %s (valid types: %s)", params.EventType, strings.Join(idx.GetEventTypes(), ", "))
	}

	// Build query
	query := "SELECT * FROM " + tableName
	args := []any{}
	var conditions []string

	if params.FromBlock != nil {
		conditions = append(conditions, "block_number >= ?")
		args = append(args, *params.FromBlock)
	}
	if params.ToBlock != nil {
		conditions = append(conditions, "block_number <= ?")
		args = append(args, *params.ToBlock)
	}
	if params.Address != "" {
		// Build address filter based on event type
		var addrFilters []string
		switch eventType {
		case "transfer":
			addrFilters = []string{
				"from_address = ?",
				"to_address = ?",
			}
		case "approval":
			addrFilters = []string{
				"owner_address = ?",
				"spender_address = ?",
			}
		}
		if len(addrFilters) > 0 {
			conditions = append(conditions, "("+strings.Join(addrFilters, " OR ")+")")
			for range addrFilters {
				args = append(args, params.Address)
			}
		}
	}

	if len(conditions) > 0 {
		query += " WHERE " + strings.Join(conditions, " AND ")
	}

	// Get total count
	countQuery := strings.Replace(query, "SELECT *", "SELECT COUNT(*)", 1)
	var total int
	if err := idx.db.QueryRowContext(ctx, countQuery, args...).Scan(&total); err != nil {
		return nil, 0, fmt.Errorf("failed to get total count: %w", err)
	}

	// Apply sorting with whitelist to prevent SQL injection
	allowedSortColumns := map[string]bool{
		"block_number": true,
		"tx_index":     true,
		"log_index":    true,
	}
	
	sortBy := "block_number" // default
	if params.SortBy != "" {
		// Validate sort column is in whitelist
		if allowedSortColumns[params.SortBy] {
			sortBy = params.SortBy
		}
		// If not in whitelist, silently use default (block_number)
	}
	
	// Validate sort order (only allow ASC or DESC, case-insensitive)
	sortOrder := "DESC" // default
	if strings.ToLower(params.SortOrder) == "asc" {
		sortOrder = "ASC"
	}
	
	query += fmt.Sprintf(" ORDER BY %s %s", sortBy, sortOrder)

	// Apply pagination
	query += " LIMIT ? OFFSET ?"
	args = append(args, params.Limit, params.Offset)

	// Execute query and scan
	events, err := scanFunc(idx, ctx, query, args)
	if err != nil {
		return nil, 0, err
	}

	return events, total, nil
}

// GetStats returns statistics about the indexed data.
func (idx *ERC20Indexer) GetStats(ctx context.Context) (any, error) {
	stats := make(map[string]any)

	eventCounts := make(map[string]int64)
	var totalEvents int64
	var earliestBlock, latestBlock uint64

	// Stats for Transfer
	{
		var count int64
		if err := idx.db.QueryRowContext(ctx,
			"SELECT COUNT(*) FROM transfers").Scan(&count); err != nil {
			return nil, fmt.Errorf("failed to get Transfer count: %w", err)
		}
		eventCounts["Transfer"] = count
		totalEvents += count

		var earliest, latest uint64
		if err := idx.db.QueryRowContext(ctx,
			"SELECT COALESCE(MIN(block_number), 0), COALESCE(MAX(block_number), 0) FROM transfers").Scan(&earliest, &latest); err != nil {
			return nil, fmt.Errorf("failed to get Transfer block range: %w", err)
		}
		earliestBlock = earliest
		latestBlock = latest
	}
	// Stats for Approval
	{
		var count int64
		if err := idx.db.QueryRowContext(ctx,
			"SELECT COUNT(*) FROM approvals").Scan(&count); err != nil {
			return nil, fmt.Errorf("failed to get Approval count: %w", err)
		}
		eventCounts["Approval"] = count
		totalEvents += count

		var earliest, latest uint64
		if err := idx.db.QueryRowContext(ctx,
			"SELECT COALESCE(MIN(block_number), 0), COALESCE(MAX(block_number), 0) FROM approvals").Scan(&earliest, &latest); err != nil {
			return nil, fmt.Errorf("failed to get Approval block range: %w", err)
		}
		if earliest > 0 && (earliestBlock == 0 || earliest < earliestBlock) {
			earliestBlock = earliest
		}
		if latest > latestBlock {
			latestBlock = latest
		}
	}
	stats["total_events"] = totalEvents
	stats["event_counts"] = eventCounts
	stats["earliest_block"] = earliestBlock
	stats["latest_block"] = latestBlock

	return stats, nil
}

// GetEventTypes returns the list of event type names this indexer handles.
func (idx *ERC20Indexer) GetEventTypes() []string {
	return []string{
		"Transfer",
		"Approval",
	}
}
