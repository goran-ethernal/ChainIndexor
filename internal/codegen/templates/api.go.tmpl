// Code generated by indexer-gen. DO NOT EDIT.
package {{.Package}}

import (
	"context"
	"fmt"
	"strings"

	"github.com/goran-ethernal/ChainIndexor/pkg/indexer"
	"github.com/russross/meddler"
)

// Ensure {{.Name}}Indexer implements indexer.Queryable
var _ indexer.Queryable = (*{{.Name}}Indexer)(nil)

// QueryEvents retrieves events based on the provided query parameters.
func (idx *{{.Name}}Indexer) QueryEvents(ctx context.Context, params indexer.QueryParams) (any, int, error) {
	// Determine which table to query based on event type (case-insensitive)
	var tableName string
	var scanFunc func(*{{.Name}}Indexer, context.Context, string, []any) (any, error)

	eventType := strings.ToLower(params.EventType)
	switch eventType {
	{{range .Events}}case "{{ToLower .Name}}":
		tableName = "{{ToSnakeCase .Name}}s"
		scanFunc = func(idx *{{$.Name}}Indexer, ctx context.Context, query string, args []any) (any, error) {
			rows, err := idx.db.QueryContext(ctx, query, args...)
			if err != nil {
				return nil, fmt.Errorf("failed to query {{.Name}} events: %w", err)
			}
			defer rows.Close()

			var events []*{{.Name}}
			if err := meddler.ScanAll(rows, &events); err != nil {
				return nil, fmt.Errorf("failed to scan {{.Name}} events: %w", err)
			}
			return events, nil
		}
	{{end}}default:
		return nil, 0, fmt.Errorf("unknown event type: %s (valid types: %s)", params.EventType, strings.Join(idx.GetEventTypes(), ", "))
	}

	// Build query
	query := "SELECT * FROM " + tableName
	args := []any{}
	var conditions []string

	if params.FromBlock != nil {
		conditions = append(conditions, "block_number >= ?")
		args = append(args, *params.FromBlock)
	}
	if params.ToBlock != nil {
		conditions = append(conditions, "block_number <= ?")
		args = append(args, *params.ToBlock)
	}
	if params.Address != "" {
		// Build address filter based on event type
		var addrFilters []string
		switch eventType {
		{{- range .Events}}
		case "{{ToLower .Name}}":
			addrFilters = []string{
				{{- range .Params}}{{if eq .Type "address"}}
				"{{ToSnakeCase .Name}}_address = ?",
				{{- end}}{{end}}
			}
		{{- end}}
		}
		if len(addrFilters) > 0 {
			conditions = append(conditions, "("+strings.Join(addrFilters, " OR ")+")")
			for range addrFilters {
				args = append(args, params.Address)
			}
		}
	}

	if len(conditions) > 0 {
		query += " WHERE " + strings.Join(conditions, " AND ")
	}

	// Get total count
	countQuery := strings.Replace(query, "SELECT *", "SELECT COUNT(*)", 1)
	var total int
	if err := idx.db.QueryRowContext(ctx, countQuery, args...).Scan(&total); err != nil {
		return nil, 0, fmt.Errorf("failed to get total count: %w", err)
	}

	// Apply sorting with whitelist to prevent SQL injection
	allowedSortColumns := map[string]bool{
		"block_number": true,
		"tx_index":     true,
		"log_index":    true,
	}
	
	sortBy := "block_number" // default
	if params.SortBy != "" {
		// Validate sort column is in whitelist
		if allowedSortColumns[params.SortBy] {
			sortBy = params.SortBy
		}
		// If not in whitelist, silently use default (block_number)
	}
	
	// Validate sort order (only allow ASC or DESC, case-insensitive)
	sortOrder := "DESC" // default
	if strings.ToLower(params.SortOrder) == "asc" {
		sortOrder = "ASC"
	}
	
	query += fmt.Sprintf(" ORDER BY %s %s", sortBy, sortOrder)

	// Apply pagination
	query += " LIMIT ? OFFSET ?"
	args = append(args, params.Limit, params.Offset)

	// Execute query and scan
	events, err := scanFunc(idx, ctx, query, args)
	if err != nil {
		return nil, 0, err
	}

	return events, total, nil
}

// GetStats returns statistics about the indexed data.
func (idx *{{.Name}}Indexer) GetStats(ctx context.Context) (any, error) {
	stats := make(map[string]any)

	eventCounts := make(map[string]int64)
	var totalEvents int64
	var earliestBlock, latestBlock uint64

	{{range $i, $event := .Events -}}
	// Stats for {{$event.Name}}
	{
		var count int64
		if err := idx.db.QueryRowContext(ctx,
			"SELECT COUNT(*) FROM {{ToSnakeCase $event.Name}}s").Scan(&count); err != nil {
			return nil, fmt.Errorf("failed to get {{$event.Name}} count: %w", err)
		}
		eventCounts["{{$event.Name}}"] = count
		totalEvents += count

		var earliest, latest uint64
		if err := idx.db.QueryRowContext(ctx,
			"SELECT COALESCE(MIN(block_number), 0), COALESCE(MAX(block_number), 0) FROM {{ToSnakeCase $event.Name}}s").Scan(&earliest, &latest); err != nil {
			return nil, fmt.Errorf("failed to get {{$event.Name}} block range: %w", err)
		}
		{{if eq $i 0 -}}
		earliestBlock = earliest
		latestBlock = latest
		{{- else -}}
		if earliest > 0 && (earliestBlock == 0 || earliest < earliestBlock) {
			earliestBlock = earliest
		}
		if latest > latestBlock {
			latestBlock = latest
		}
		{{- end}}
	}
	{{end -}}

	stats["total_events"] = totalEvents
	stats["event_counts"] = eventCounts
	stats["earliest_block"] = earliestBlock
	stats["latest_block"] = latestBlock

	return stats, nil
}

// GetEventTypes returns the list of event type names this indexer handles.
func (idx *{{.Name}}Indexer) GetEventTypes() []string {
	return []string{
		{{- range .Events}}
		"{{.Name}}",
		{{- end}}
	}
}
