// Code generated by indexer-gen. DO NOT EDIT.
package {{.Package}}

import (
	"database/sql"
	"errors"
	"fmt"
	"math/big"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/goran-ethernal/ChainIndexor/internal/logger"
	"github.com/goran-ethernal/ChainIndexor/pkg/config"
	"github.com/goran-ethernal/ChainIndexor/pkg/indexer"
	"github.com/russross/meddler"
	"{{.ImportPath}}/migrations"
)

// Compile-time check to ensure {{.Name}}Indexer implements indexer.Indexer interface.
var _ indexer.Indexer = (*{{.Name}}Indexer)(nil)

// {{.Name}}Indexer indexes {{.Name}} events.
type {{.Name}}Indexer struct {
	cfg config.IndexerConfig
	db  *sql.DB
	log *logger.Logger

	// Map of contract addresses to event topic hashes
	eventsToIndex map[common.Address]map[common.Hash]struct{}

	// Event signature hashes for quick lookup
	{{- range .Events}}
	{{ToLowerCamelCase .Name}}Topic common.Hash
	{{- end}}
}

// New{{.Name}}Indexer creates a new {{.Name}} indexer.
func New{{.Name}}Indexer(cfg config.IndexerConfig, log *logger.Logger) (*{{.Name}}Indexer, error) {
	// Run migrations to set up the database schema
	if err := migrations.RunMigrations(cfg.DB); err != nil {
		return nil, fmt.Errorf("failed to run migrations: %w", err)
	}

	// Create database connection from config
	database, err := sql.Open("sqlite3", cfg.DB.Path)
	if err != nil {
		return nil, fmt.Errorf("failed to create database: %w", err)
	}

	// Calculate event topic hashes
	{{- range .Events}}
	{{ToLowerCamelCase .Name}}Topic := crypto.Keccak256Hash([]byte("{{.CanonicalSignature}}"))
	{{- end}}

	// Build the events to index map
	eventsToIndex := make(map[common.Address]map[common.Hash]struct{})

	for _, contract := range cfg.Contracts {
		topics := make(map[common.Hash]struct{})

		for _, eventSig := range contract.Events {
			topic := crypto.Keccak256Hash([]byte(eventSig))
			topics[topic] = struct{}{}
		}

		// Parse contract address from string
		address := common.HexToAddress(contract.Address)
		eventsToIndex[address] = topics
	}

	return &{{.Name}}Indexer{
		cfg:           cfg,
		db:            database,
		log:           log,
		eventsToIndex: eventsToIndex,
		{{- range .Events}}
		{{ToLowerCamelCase .Name}}Topic: {{ToLowerCamelCase .Name}}Topic,
		{{- end}}
	}, nil
}

// Name returns the name of the indexer.
func (idx *{{.Name}}Indexer) Name() string {
	return idx.cfg.Name
}

// EventsToIndex returns the map of contract addresses to event topic hashes.
func (idx *{{.Name}}Indexer) EventsToIndex() map[common.Address]map[common.Hash]struct{} {
	return idx.eventsToIndex
}

// HandleLogs processes a batch of logs and stores events.
func (idx *{{.Name}}Indexer) HandleLogs(logs []types.Log) error {
	if len(logs) == 0 {
		return nil
	}

	tx, err := idx.db.Begin()
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer func() {
		if err := tx.Rollback(); err != nil && !errors.Is(err, sql.ErrTxDone) {
			idx.log.Errorf("failed to rollback transaction: %v", err)
		}
	}()

	{{- range .Events}}
	{{ToLowerCamelCase .Name}}Count := 0
	{{- end}}

	for _, log := range logs {
		if len(log.Topics) == 0 {
			continue
		}

		topic := log.Topics[0]

		switch topic {
		{{- range .Events}}
		case idx.{{ToLowerCamelCase .Name}}Topic:
			event, err := idx.parse{{.Name}}(&log)
			if err != nil {
				idx.log.Warnf("failed to parse {{.Name}} event at block %d, tx %s: %v",
					log.BlockNumber, log.TxHash.Hex(), err)
				continue
			}

			if err := meddler.Insert(tx, "{{TableName .Name}}", event); err != nil {
				return fmt.Errorf("failed to insert {{ToLowerCamelCase .Name}}: %w", err)
			}
			{{ToLowerCamelCase .Name}}Count++
		{{end}}
		}
	}

	if err := tx.Commit(); err != nil {
		return fmt.Errorf("failed to commit transaction: %w", err)
	}

	idx.log.Infof("Indexed {{range $i, $e := .Events}}{{if $i}}, {{end}}%d {{Pluralize (ToLowerCamelCase .Name)}}{{end}}"{{range .Events}}, {{ToLowerCamelCase .Name}}Count{{end}})

	return nil
}

// HandleReorg handles a blockchain reorganization by removing data from the reorg point.
func (idx *{{.Name}}Indexer) HandleReorg(blockNum uint64) error {
	tx, err := idx.db.Begin()
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer func() {
		if err := tx.Rollback(); err != nil && !errors.Is(err, sql.ErrTxDone) {
			idx.log.Errorf("failed to rollback transaction: %v", err)
		}
	}()

	{{range $i, $e := .Events}}
	// Delete {{Pluralize (ToLowerCamelCase $e.Name)}} from the reorg point
	delete{{$e.Name}}sQuery := {{"`"}}DELETE FROM {{TableName $e.Name}} WHERE block_number >= ?{{"`"}}
	{{if eq $i 0}}result, err := {{else}}result, err = {{end}}tx.Exec(delete{{$e.Name}}sQuery, blockNum)
	if err != nil {
		return fmt.Errorf("failed to delete {{Pluralize (ToLowerCamelCase $e.Name)}}: %w", err)
	}
	{{Pluralize (ToLowerCamelCase $e.Name)}}Deleted, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to get rows affected for {{Pluralize (ToLowerCamelCase $e.Name)}}: %w", err)
	}
	{{end}}

	if err := tx.Commit(); err != nil {
		return fmt.Errorf("failed to commit transaction: %w", err)
	}

	idx.log.Infof("Handled reorg from block %d: deleted {{range $i, $e := .Events}}{{if $i}}, {{end}}%d {{Pluralize (ToLowerCamelCase .Name)}}{{end}}",
		blockNum{{range .Events}}, {{Pluralize (ToLowerCamelCase .Name)}}Deleted{{end}})

	return nil
}

// StartBlock returns the block number from which this indexer should start.
func (idx *{{.Name}}Indexer) StartBlock() uint64 {
	return idx.cfg.StartBlock
}

// Close closes the database connection.
func (idx *{{.Name}}Indexer) Close() error {
	return idx.db.Close()
}

{{range .Events}}
// parse{{.Name}} parses a {{.Name}} event from a log.
// Event signature: {{.Raw}}
func (idx *{{$.Name}}Indexer) parse{{.Name}}(log *types.Log) (*{{.Name}}, error) {
	expectedTopics := {{len .IndexedParams}} + 1 // signature + indexed params
	if len(log.Topics) != expectedTopics {
		return nil, fmt.Errorf("invalid {{.Name}} event: expected %d topics, got %d",
			expectedTopics, len(log.Topics))
	}
	{{- $nonIndexedCount := len .NonIndexedParams}}
	{{- if gt $nonIndexedCount 0}}

	expectedDataSize := {{$nonIndexedCount}} * 32 // {{$nonIndexedCount}} non-indexed param(s)
	if len(log.Data) != expectedDataSize {
		return nil, fmt.Errorf("invalid {{.Name}} event: expected %d bytes of data, got %d",
			expectedDataSize, len(log.Data))
	}
	{{- end}}
	{{- $topicIndex := 1}}
	{{- range .IndexedParams}}

	{{- if eq .Type "address"}}
	{{ToLowerCamelCase .Name}} := common.BytesToAddress(log.Topics[{{$topicIndex}}].Bytes())
	{{- else if eq .Type "bytes32"}}
	{{ToLowerCamelCase .Name}} := log.Topics[{{$topicIndex}}]
	{{- else if or (hasPrefix .Type "uint") (hasPrefix .Type "int")}}
	{{ToLowerCamelCase .Name}}Big := new(big.Int).SetBytes(log.Topics[{{$topicIndex}}].Bytes())
	{{ToLowerCamelCase .Name}} := {{ToLowerCamelCase .Name}}Big.String()
	{{- else}}
	{{ToLowerCamelCase .Name}} := log.Topics[{{$topicIndex}}]
	{{- end}}
	{{- $topicIndex = add $topicIndex 1}}
	{{- end}}
	{{- $dataOffset := 0}}
	{{- range .NonIndexedParams}}

	{{- if eq .Type "address"}}
	{{ToLowerCamelCase .Name}} := common.BytesToAddress(log.Data[{{$dataOffset}}:{{add $dataOffset 32}}])
	{{- else if eq .Type "bytes32"}}
	{{ToLowerCamelCase .Name}} := common.BytesToHash(log.Data[{{$dataOffset}}:{{add $dataOffset 32}}])
	{{- else if or (hasPrefix .Type "uint") (hasPrefix .Type "int")}}
	{{ToLowerCamelCase .Name}}Big := new(big.Int).SetBytes(log.Data[{{$dataOffset}}:{{add $dataOffset 32}}])
	{{ToLowerCamelCase .Name}} := {{ToLowerCamelCase .Name}}Big.String()
	{{- else if eq .Type "bool"}}
	{{ToLowerCamelCase .Name}} := new(big.Int).SetBytes(log.Data[{{$dataOffset}}:{{add $dataOffset 32}}]).Uint64() != 0
	{{- else}}
	// TODO: Handle {{.Type}} parsing
	{{ToLowerCamelCase .Name}} := log.Data[{{$dataOffset}}:{{add $dataOffset 32}}]
	{{- end}}
	{{- $dataOffset = add $dataOffset 32}}
	{{- end}}

	return &{{.Name}}{
		BlockNumber: log.BlockNumber,
		BlockHash:   log.BlockHash,
		TxHash:      log.TxHash,
		TxIndex:     log.TxIndex,
		LogIndex:    log.Index,
		{{- range .Params}}
		{{ToPascalCase .Name}}: {{ToLowerCamelCase .Name}},
		{{- end}}
	}, nil
}
{{end}}
